
# 1 基础认知
## 1.1 定义和类别
**定义**
计算机:是一种能**自动**对**数字化信息**进行**算术和逻辑运算**
计算机系统:包括硬件和软件部分
硬件
![image.png](http://verification.fengzhongzhihan.top/202312202254754.png)

软件
![image.png|275](http://verification.fengzhongzhihan.top/202309142227307.png)
%% **类别**
- 桌面计算机
	- 倾向于性价比优化
- 服务器
	- 倾向于可用性和可扩展性
- 集群/仓库级计算机
	- 前者是局域网连接的台式计算机,每个节点
- 嵌入式系统
	- 倾向于成本和实时响应 %%
## 1.2 层次结构
![image.png](http://verification.fengzhongzhihan.top/202309142301121.png)

实现不同程序的转换
- 翻译:将上层程序变为下层程序的等效程序, 并在下层程序去实现
- 解释:将下层模仿上层的指令.逐条解释并实现

计算机系统的不同用户
- 最终用户(感知应用程序)
- 系统管理员(感知计算机系统的硬件层面,系统管理层面以及相关的人机交互界面和实用程序)
- 应用程序员(写代码写程序)(运用IDE来写代码)
- 系统程序员:(熟悉指令系统,机器结构和相关功能特性)

%% - 注:hormony具有开发社区,可以进去写 %%

ISA(introduction set architectrue):指令集体系结构
- 硬件和软件的接口
- 规定了如何使用硬件,各种指令的格式,操作种类,以及对应操作数的相应规定
- 是必不可少的抽象层
	- 没有它，软件无法使用计算机硬件！没有它，一台计算机不能称为“通用计算机”

![image.png](http://verification.fengzhongzhihan.top/202312202303463.png)

## 1.3 冯-诺伊曼架构
核心思想:存储程序
- 任何要计算机完成的工作都要先被编写成程序，然后将程序和原始数据送入主存并启动执行。一旦程序被启动，计算机应能在不需操作人员干预下，自动完成逐条取出指令和执行指令的任务。

![image.png|400](http://verification.fengzhongzhihan.top/202312202304699.png)

计算机五大组成:运算器,控制器,存储器,输入设备, 输出设备
- 运算器:ALU 
	- (大多数计算机用32,64,128位)
	- 系统优先选择二进制补码的表示形式
- 控制器 (完成一条指令)
	- PC(取指令)  
	- IR(分析指令)   
	- CU(执行指令)   
	- 和运算器组成CPU ! 
- 存储器(通过MAR和MDR进行交互)
	- 内存
		- 只读存储器
		- 随机存取存储器(# dynamic random access memory)
		- 指令 -> MAR -> 存储器 -> MDR -> 输出指令数据
	- 外存
		- U盘. 机械硬盘...
 - 数据和指令均用二进制表示
	- 指令执行过程中，指令和数据被从存储器取到CPU，存放在CPU内的寄存器中，指令在IR中，数据在GPR中。
	- 指令包含
		- 操作性质（操作码）
		- 源操作数1 或/和 源操作数2    （立即数、寄存器编号、存储地址）
		- 目的操作数地址   （寄存器编号、存储地址）



程序运行过程
1. PC发出信号, 放到MAR中(地址寄存器), 从存储器里面取指令, 放到MDR中, 再放到IR中, 进行指令的分析,后到CU中进行指令执行
2. 再发出信号, 放到MAR中, 从存储器里面取数据, 放入MDR中, 再进行运算, 最后把结果存到对应位置

![image.png|625](http://verification.fengzhongzhihan.top/202309161100703.png)

举例

![image.png|550](http://verification.fengzhongzhihan.top/202309161104404.png)


%% 部件之间的联系方式
- 早期:分散
- 现在:总线
- 未来:点对点(高速公路但是复杂)

现实问题:数据量巨大,存储器读写速度<<CPU处理速度 %%
## 1.4 程序开发过程
早期
%% - 机器语言,写在纸袋/卡片上
	- 穿孔表示0,未穿孔表示1
- 汇编语言,用了帮助记忆的符号和标号表示位置,更加简单
	- 但写print函数仍然要写上千行命令
	- jxx表示jump
	- 移植性也不好 %%
- 高级语言处理过程
	- ![image.png|350](http://verification.fengzhongzhihan.top/202309161101181.png)

	- 预处理:对伪指令以及特殊符号进行处理
		- 头文件, 宏定义, 条件编译, 特殊符号 Line File 等
	- 编译:将高级->汇编
		- 词法分析
		- 语法分析
		- 生成代码
			- 可以立即执行的机器语言代码；
	        - 待装配的机器语言模块，当需要执行时，由链接装入程序把它们和某些运行程序连接起来，转换成能执行的机器语言代码；
	        - 汇编语言代码，须经过汇编程序汇编后，成为可执行的机器语言代码。

	- 汇编:将汇编语言翻译成-> 目标机器指令
		生成文件(可重定位目标文件)包括
		- 代码段
		- 数据段
	- 链接:其主要工作是将有关的目标文件彼此相链接
		- 静态链接:把函数代码从静态链接库复制到目标执行文件
		- 动态链接:把函数代码插入到动态链接库或共享对象的某个对象文件中，链接程序只在最终的可执行程序中记录对象名称和少量其他登记信息的一部分。
	- gcc编译过程举例
	- ![image.png|550](http://verification.fengzhongzhihan.top/202312202334253.png)


**程序的执行**
可执行文件分为包含了程序指令的代码段和包含了程序全局变量和静态数据的数据段，
CPU取出并执行一条指令的时间被称为指令周期，不同指令的指令周期可能不同。
## 1.5 计算机性能
性能指标
- 响应时间(执行时间):完成一项任务总时间(反比)(s)
- 吞吐率/带宽:单位时间内完成任务数目(正比)
注意:两者不成反比,比如四核处理器和两核处理器

性能度量
- 度量方式 : 程序的执行时间
	- CPU执行时间(主要)
		- 计算公式$:CPU执行时间=时钟周期数* 时钟周期$
			- 时钟周期=1/时钟频率
	- 其他时间(忽略)


**指令性能**
两大度量方法
- CPI
- MIPS
计算方法
- $时钟周期数=指令数* CPI(指令平均时钟周期数)$
- ![image.png|329](http://verification.fengzhongzhihan.top/202312202338667.png)
- $MIPS(指令速度)=指令数/(执行时间* 10^6)=时钟频率/(CPI*10^6)$
- 则$$CPU执行时间 = 时钟周期*CPI*指令数
$$
---------------------------------------------------------------------------
**例题**

![image.png](http://verification.fengzhongzhihan.top/202309161109712.png)


![image.png](http://verification.fengzhongzhihan.top/202309161112280.png)
![image.png](http://verification.fengzhongzhihan.top/202309161112501.png)


![image.png](http://verification.fengzhongzhihan.top/202312202341209.png)
![image.png](http://verification.fengzhongzhihan.top/202312202341119.png)


# 2 组合电路和时序电路

信号分类
- 模拟信号:时间和数值上都连续变化
- 数字信号:时间和数值上都离散变化

数字电路
- 组合电路
- 时序电路

## 2.1 组合电路
- 特点:任意时刻的输出仅仅取决于该时刻的输入,而与之前的电路状态无关
- 描述方法:真值表,布尔代数,逻辑图
	- 真值表
	- ![image.png](http://verification.fengzhongzhihan.top/202312251701883.png)

	- 布尔代数 用逻辑表达式
	- 逻辑图![image.png](http://verification.fengzhongzhihan.top/202312251701913.png)

- %% 特殊电路
	- 同或电路:输入相同输出为1
	- 一致电路:也是同或电路
	例题![image.png](http://verification.fengzhongzhihan.top/202309200843307.png)
	常见组合逻辑电路:加法器
	![image.png](http://verification.fengzhongzhihan.top/202309200845562.png) %%

## 2.2 时序电路
**特点**:输出不仅与此刻的输入有关,还和之前的输入有关

![image.png](http://verification.fengzhongzhihan.top/202312251703428.png)

**区别**:时序电路考虑状态,组合电路不考虑
%% **分类**
按触发器的动作特点不同
- 同步时序逻辑电路:统一的时钟信号控制触发器状态变化
- 异步时序逻辑电路:没有统一的时钟信号,状态变化不同时发生
按输出信号特点不同
- Mealy:输出取决于存储电路状态+输入
- Moore:输出取决于存储电路状态 %%

%%
## 2.3 锁存器,触发器,寄存器
**SR锁存器**
定义:是一种静态存储单元,以某种电平状态暂存信号,可以记录为0/1
**触发器**
相比SR增加了一个触发信号的输入端
定义:构建时序电路基本单元,可以存储一位的二进制信息
- 在输入信号的作用下,可以被置为两种稳定的状态
- 输入信号取消后,可以保持状态不变
- 需要全局的同步控制信号:时钟信号

**触发器分类**
按触发方式
- 基本:直接电平触发
- 同步:电平触发
- 边沿:边沿触发
- 主从:脉冲触发
按逻辑功能
- SR
	- CLK=1时,SR通过G1,G2加到右侧锁存器上,CLK=0时,不影响
	- ![image.png|275](http://verification.fengzhongzhihan.top/202309200858524.png)

- JK
	- JK触发器具有置0、置1、保持和翻转功能,功能最强大
- D
	- 当CLK发生变化的时候就会产生影响,若不变则不影响
- T
	- 具有反转功能的触发器,将JK的J和K相连作为输入端即可

**寄存器**
- 一位
	- 由触发器组成
- 四位
	-  由四个触发器组成
- 移位
	- 移位寄存器就是将寄存器所存各位数据，在每个移位脉冲的作用下，向左或向右移动一位 %%

## 2.3 计算机子系统
### 2.3.1 CPU子系统
CPU功能
- 指令控制:保证主存储器中的指令序列按照正确的顺序执行。
- 操作控制：将指令“翻译”为正确的操作信号，并传达到相关的部件，保证这些操作在执行时能够正确、稳定。
- 时间控制：对各种操作进行时间上的定时
- 数据加工：CPU对相关数据进行加、减、乘、除等基本或复合型操作。

**组成**
- 运算器
	- 基础单元:一位全加器
	- 进阶:行波进位加法器
- 控制器
	- 从主存储器中取出指令并控制记录下一条指令的地址；
	- 进行指令译码、测试，生成对应的控制信号；
	- 控制CPU、主存储器、I/O设备之间的数据流
- 寄存器
	- 存储二进制数据,由触发器构成

### 2.3.2 总线子系统

定义:总线是构成计算机系统的互联机构。是系统内各功能部件之间进行信息传送的公共通路。
**分类**
按连接部件
- 内部总线:芯片内部逻辑器件的连接总线
- 局部总线:CPU和其他部件的连接总线, 介于CPU内部总线和系统总线之间
- 系统总线:计算机各功能部件的连接总线通信总线，微机系统与微机系统、其他设备之间的连接总线。
	%% 按传送的信息
- 数据总线
	- 负责传输数据，数据线是双向的
- 地址总线
	- 负责传输数据地址，只能单向传送主存与设备的地址
- 控制总线
	- 负责传输控制信号，控制线是双向的

**信息传输方式**
- 串行传输:效率更高
- 并行传输

总线连接方式
- 单总线
- 双总线:增加了内存总线(内存<=>CPU)
- 多总线:增加了IO总线

### 2.3.3 内存子系统
线
- 地址线
- 数据线
内存芯片
- CS(芯片选择)
- WE(写),写入信息
- OE(输出),从芯片中读取 %%

# 3 处理器体系
## 3.1 指令集(ISA)体系结构
定义:指令集架构，是计算机体系结构中与程序设计有关的部分，包含了基本数据类型、指令集、寄存器、寻址模式、存储体系、中断、异常处理以及外部I/O。指令集架构包含一系列的opcode（机器语言中的操作码），以及由特定处理器执行的基本命令。

> 二八定律:约仅有20%的因素影响80%的结果
	也就是说:所有的变因中,重要的只有20%

**分类**
- 复杂指令集(CISC)(Complex Instruction Set Computing)
- 精简指令集(RISC)(Reduced Instruction Set Computing)
- 显式并行指令集(EPIC)(Explicity Parallel Instruction Computing)
- 超长指令字指令集(VLIW)(Very Long Instruction Word)
### 3.1.1 复杂/精简指令集
**复杂指令集**
- 每个功能都提供API(intel处理器)
- 主要特点
	- (1) 指令系统庞大，指令功能复杂；
		(2) 指令格式多，一般大于4种；
		(3) 指令寻址方式多，一般大于4种；
		(4) 指令字长不固定；
		(5) 各种指令均可访问内存；	
		(6) 不同指令使用频率相差很大；
		(7) 大多数指令需要多个机器周期才能完成；
		(8) 指令系统由微程序控制
**精简指令集**
- 简化版复杂指令集(arm处理器)
- 主要特点
	- (1) 指令系统简单，指令条数少；
	(2) 寻址方式少；
	(3) 指令格式简单，指令长度固定，操作码字段位置固定；
	(4) 拥有更多的通用寄存器，寄存器操作较多，减少了对存储器的访问。

- 主要区别
	- 指令系统
		- RISC专注于经常使用的指令,需要组合来实现复杂功能,而CISC处理复杂任务效率高
	- 存储器操作
		- RISC大部分指令只能访问寄存器,而CISC操作比较直接,需要注意安全
	- 程序编写
		- RISC汇编语言程序因为需要组合指令以实现特殊功能，一般需要较大的内存空间，实现特殊功能时程序复杂，不易设计; 而CISC 汇编语言程序编程相对简单，科学计算及复杂操作的程序设计相对容易，效率较高
	- 中断
		- RISC可以在执行的适当地方响应中断,而CISC必须一条指令结束才能响应中断
	- CPU和设计周期
		- RISC面积小,功耗低,设计周期短;CISC面积大,功耗大,设计周期长
	- 用户使用
		- RISC 微处理器结构简单，指令规整，性能容易控制，易学易用；CISC微处理器结构复杂，功能强大，更容易实现特殊功能。
	- 应用范围
		- 基于RISC指令集的设备功能强大且功耗较低，常应用在移动设备领域；而基于CISC指令集的设备则主要集中在功能强大且功耗较高的计算机市场中。

### 3.1.2 3%% .1.2 二进制翻译技术
**发展历程**
- X86指令集架构(CISC)
- MIPS(RISC)
- ARM(RISC)
	- 已经推出了ARMV9
- RISC-V(RISC)
	- 开源指令集架构
- LoongArch
	- LA,国产,包含了架构翻译的指令子集


**原理**
编译技术
区别:
- C编译:高级语言->低级语言
- 二进制翻译:机器语言->机器语言
功能:使得新的指令集架构实现了对传统架构软件的支持

**分类**
概念上
- 前端解码
- 中断分析优化
- 后端翻译
基于软件
- 解释执行:翻译单句
- 静态翻译:翻译全篇
- 动态翻译:翻译片段 %%
## 3.2 LoongArch(RISC)

### 3.2.1 特点

典型特征:
- 指令长度固定+编码格式规整

采用架构
- load/store

绝大多数指令有两个源操作数和一个目的操作数

LA64兼容LA32:
- LA32软件可执行文件可以直接运行在LA64上

组织形式
- 基础部分+扩展部分
- 扩展部分包括二进制翻译扩展（Loongson Binary Translation,简称LBT）、虚拟化扩展（Loongson  Virtualization,简称 LVZ）、向量扩展 （Loongson SIMD Extension，简称 LSX）和高级向量扩展（Loongson Advanced SIMD Extension，简称 LASX ）。

### 3.2.2 指令格式
**编码方式**

定长编码
- 所有指令都是32位的,且地址按照4字节边界对齐

**特点:**
- 所有的操作码都是从指令的第31比特（最高位）开始从高到低依次摆放 (从左往右)
- 所有的寄存器操作数域都是从第0比特（最低位）开始从低到高依次摆放 (从右往左)
- 若指令中存在立即数操作数的话，立即数域就要位于操作码域和寄存器域之间。(中间)
![image.png](http://verification.fengzhongzhihan.top/202309202119274.png)

典型的编码格式
![image.png|500](http://verification.fengzhongzhihan.top/202309202120651.png)

R前数字x代表有x个寄存器操作数(每个寄存器占5位)
I后数字y代表有y位长度的立即数域
剩下的位数都是opcode长度(操作码)

![image.png](http://verification.fengzhongzhihan.top/202312251730316.png)
### 3.2.3 指令助记符

**汇编助记格式**

指令名+操作数
- **指令前缀**:通过指令名前缀字母判断是整数还是浮点数
	- 无前缀:整数
	- 以v开头是128位,xv开头是256位
	- F:非向量浮点数  VF:128位向量浮点 XVF:256位向量浮点
- **指令后缀** : 用.XX来表示操作类型X
	- B,H,W,D分别表示数据类型为有符号字节,有符号半字,有符号字, 有符号双字
		- 如果再加上U表示无符号
	- 可以有多个后缀同时存在，依次从左往右列出每个操作数的数据类型情况![image.png](http://verification.fengzhongzhihan.top/202309202147771.png)
		- 寄存器操作数通过不同的首字母表明其属于哪个寄存器文件。比如前面的举例中以“rN”来标记通用寄存器，以“fN”来标记浮点寄存器，其中N是数字，表示操作的是该寄存器文件中第N号寄存器。
		- 意为将rj,rk相加存到rd
	- r表示通用寄存器,f表示浮点寄存器

### 3.2.4 寄存器类型
LA 采取的是**Load/store架构**
 - 数据存取指令是寄存器和内存之间的通信
 - 除此之外,所有指令都直接对立即数和寄存器进行操作,无需内存参与,因此寄存器较多, 是RISC的一个特点

对于**基础整数指令指令**来说
- 设置了32个通用寄存器(GR),标号r0~r31,每个寄存器位宽为GRLEN,值与指令集位数相同(32)
- 理论来说寄存器操作数可以是任意一个,但是默认r0=0,r1存储函数调用返回地址
- PC记录当前取指令的地址,宽度与GR保持一致, 为了确保程序运行的稳定性与安全性，PC寄存器中的值不能被指令直接修改, 但是可以作为源操作数被直接读取

对于**浮点指令**来说
- 浮点寄存器(FR)32个
	- 位宽未必与指令集一致,而是与操作数有关, 通常情况下为64bit, 可以根据需要仅用32位
- 条件标志寄存器(CFR)  (flag) 
	- 共有8个, 分别记为fcc0 ~ fcc7, 存放浮点比较结果,仅有一个bit, 浮点分支指令的判断条件。
- 浮点控制状态寄存器(FCSR)  (control status)
	- 共有4个,位宽都是32bit, 访问fcsr1~fcsr3的域即是访问fscr0的部分域, 修改也会进行部分修改

最后,LA还提供了状态控制寄存器(CSR)用于统筹协调
- 为软件提供4种不同的读写模式
	- 可读可写; 只读; 读取永远返回0; 唯写入1有效 ,这些操作有效保护了系统安全并使得寄存器功能得以正常实现。
- 指称域名称 : 如CSR.MISC.0就是指杂项寄存器MISC的保留域0

### 3.2.5 LA寻址方式

目的 : 找到对应的操作数

- 寄存器寻址
通过寄存器的标号(5位)去寻找操作数
- 由于无需通过访问存储器来取得操作数，因此采用寄存器寻址方式的指令具有较高的执行效率。但寄存器的总数有限使得寄存器寻址方式的使用代价较高。

- 立即数寻址
操作数作为指令的一部分，被包含在指令中
直接找到操作数

- 基址寻址
一个寄存器号+一个形式地址(地址偏移量)
可以扩大寻址范围

- 相对基址变址寻址
基址寄存器+变址寄存器
如add.w r5,r0,r6

- PC相对寻址
先将指令码中的立即数左移两位进行符号扩展得到地址的偏移量, 再加上PC得到目标地址
- 优点操作数地址不固定,便于程序浮动

### 3.2.6 数据处理指令

**数据处理指令**
包括数据处理,逻辑运算,符号扩展

- 运算
	- 不带立即数的
		- add.w	  r5, r6, r7	；
		- ADD.W将通用寄存器rj中的[31:0]位数据加上通用寄存器rk中的[31:0] 位数据，所得结果的[31:0]	位符号扩展后写入通用寄存器rd中，即rd=rj+rk。

	- 带立即数的
		- addi.w   rd, rj, si12    ,不会对溢出情况做任何特殊处理。
		- addi.w   r5, r6, 5	；  r5=r6+5
	- 减法
		- sub.w   rd, rj, rk	
	- 乘法(分为高位和地位运算)
		- mul.w    rd, rj, rk
		  mulh.w   rd, rj, rk
		  mulh.wu  rd, rj, rk
			MUL.W指令将通用寄存器rj中的数据与通用寄存器rk中的数据进行相乘，乘积结果的[31:0]位数据写入通用寄存器rd中。MULH.W将寄存器rj和rk中的数据视为有符号数进行相乘，乘积结果的[63:32]位数据写入通用寄存器rd中。MULH.WU则是将rj和rk中的数据视作无符号数进行相乘，乘积结果的[63:32]位写入通用寄存器rd中。

	- 除法
		- div.w	rd, rj, rk
			  div.wu  rd, rj, rk
			两种指令都是将通用寄存器rj中的数据除以通用寄存器rk中的数据,所得的商写入通用寄存器rd中.区别就是div.wu将数据当作无符号数进行计算,而div.w将数据当作有符号数进行计算。同时当除数是0时，指令的运行结果可以是任意值，且不会因此触发任何异常。

	- 取余
		- mod.w   rd, rj, rk
			  mod.wu  rd, rj, rk
- 在精简指令集计算机中，像开根，求对数等更复杂一些的运算方式，都是通过泰勒公式等数学手段将其转换成加减乘除等基础运算的方式实现的。

**例题**
	平方差公式 $(a+b) *(a-b)=a^2-b^2$
```LA
		ld.w    r2,r0,0		#将a装载到寄存器r2中，a在内存中的起始地址为0
		ld.w    r3,r0,32		#将b装载到寄存器r3中，b在内存中的起始地址为32
		mul.w      r4,r2,r2      	#r4=r2*r2=a*a=a2    
		mul.w  	  r5,r3,r3		#r5=r3*r3=b*b=b2
		sub.w       r6,r4,r5		#r6=r4-r5=a2-b2 
```


- 逻辑指令
	- 逻辑与指令：
		and	r5, r6, r7						#  r5=r6 & r7
		andi   r5, r6, 0101					#  r5=r6 & 5
	- 逻辑或指令：
		or	r5, r6, r7						#  r5=r6 | r7
		ori   r5, r6, 0101					#  r5=r6 | 5
	- 逻辑异或指令：
		xor	r5, r6, r7						#  r5=r6 ^ r7
		xori   r5, r6, 0101					#  r5=r6 ^ 5
	- 逻辑或非指令：
		nor	r5, r6, r7						#  r5=~（r6 | r7）
	- 逻辑非
		- nor  r5,r5,0
	- 逻辑左移指令：
		sll.w   r4, r5, r6					#  r4=r5 <<  r6
		slli.w  r4, r5, 8					#  r4=r5 <<  8
	- 逻辑右移指令：
		srl.w   r4, r5, r6					#  r4=r5 >>  r6
		srli.w  r4, r5, 8					#  r4=r5 >>  8
	- 算数右移指令：
		sra.w   r4, r5, r6					#  r4=r5 >>  r6
		srai.w  r4, r5, 8					#  r4=r5 >>  8
		**例题**
		![image.png](http://verification.fengzhongzhihan.top/202309251755012.png)
		

 **转移指令**
大部分循环和选择语句都是通过转移指令来组合实现的
分为
- 无条件跳转
- 条件跳转

- **无条件跳转**

b  offs26;
bl   offs26;
jirl   rd,rj,offs16;

- B:跳转目标地址是
	- 指令的PC值 + 
	- 指令中给出的26比特长度的立即数offs26 逻辑左移2位得到的偏移值
- BL : 跳转目标地址同B, 同时将该指令的PC值加4的结果写入到1号通用寄存器r1中。
- JIRL:跳转目标地址是 
	- 指令中给出的16比特长度的立即数offs26 逻辑左移2位得到的偏移值 + 通用寄存器rj中的值。
	- 同时将该指令的PC值加4的结果写入到通用寄存器rd中.
		- 要注意的是当rd等于0时，JIRL的功能即是一条间接跳转指令。同时，rd=0, rj=1, offsl6=0的JIRL常作为调用返回间接跳转使用.

- **有条件跳转**

LA32中条件跳转指令，其指令编码格式都是2RI16，六条分支指令的跳转目标地址计算方式都是将指令码中的16比特立即数offsl6逻辑左移2位后再符号扩展所得的偏移值 + 该分支指令的PC。 

BEQ:将指令中给出的两个通用寄存器的值进行比较，如果两者相等则跳转到目标地址
BNE:如果两者不相等则跳转到目标地址
BLT[ U ]:将指令中给出的两个通用寄存器的值视作有符号数进行比较，如果前者小于后者则跳转到目标地址
BGE[U]:前者大于后者, 则跳转到目标地址


**访存指令**

寻址方式是典型的基址寻址方式

- 访存读指令LD,写指令ST
LD:
	ld.bu    r4,r5,1(若r5的值为4,则指令的执行过程是计算4+1，然后访问地址为5的内存空间，并取回一个字节的数据在零扩展后写入r4)

**原子访存指令**
LL.W和SC.W，这两条指令结对使用用于实现原子的“读-修改-写”过程。
- LL.W指令从内存指定地址取回一个字的数据符号扩展后写入通用寄存器rd
- 在程序对该操作数完成操作后, 与之配对的SC.W指令操作同样宽度的数据且访间相同的内存地址，完成原子操作。

%% **珊障指令**
即内存屏障,为了保证CPU和编译器对内存进行操作的时候,严格按照一定顺序来执行
- DBAR指令用于完成load/store访存操作之间的栅障功能
- IBAR指令用于完成单个处理器核内部store操作与取指操作之间的同步，即确保在取指操作之前的所有store操作都已经执行完成

**特权指令**
龙芯架构中将处理器核分为4个特权等级（Privilege LeVel,简称PLV）从PLV0到PLV3。
- 所有特权等级中，PLV0是具有最高权限的特权等级，也是唯一可以使用特权指令并访问所有特权资源的特权等级。
- PLV1到PLV3这三个特权等级都不能执行特权指令访问特权资源，但是三个特权等级在MMU采用映射地址翻译模式下具有不同的访问权限
**杂项指令**
syscall code ；当SYSCALL指令执行时，将立即无条件的触发系统调用异常，而在指令码中的code域携带的信息可以提供给异常处理例程作为所传递的参数使用。

break code  ；当BREAK指令执行时，将立即无条件触发断点异常，使得当前进程停止运行，指令码中code域携带的信息可以提供给异常处理例程作为所传递的参数使用。 %%

### 3.2.7 汇编语言源程序格式

![image.png](http://verification.fengzhongzhihan.top/202312251946314.png)

汇编代码是机器代码的符号表示，其在大体上与汇编助记符的指令格式是一致的，不过在组织结构上做出了一定的规定

以C语言为例 
```c
#include< stdio.h>

int main()
{
	printf("Hello World\n");
	printf("Welcome to LoongArch World !\n");
	return 0;
}
```


![image.png](http://verification.fengzhongzhihan.top/202312251950795.png)

```LA
	.text
	.section	.rodata
	.align	3
.LC0:
	.ascii	"Hello World!\000"
	.align	3
.LC1:
	.ascii	"Welcome to LoongArch World!\000"
	.text
	.align	2
	.globl	main
	.type	main, @function
main:
	addi.d $r3, $r3, -16: 分配了16个字节的栈空间。
	st.d $r1, $r3, 8: 将 $r1 寄存器的值存储到偏移8个字节的栈内。
	stptr.d $r22, $r3, 0: 将 $r22 寄存器的值存储到栈内。
	addi.d $r22, $r3, 16: 计算并存储了 $r22 的值作为栈帧的偏移地址。
	la.local $r4, .LC0: 将 .LC0 的地址加载到 $r4 寄存器。
	bl %plt(puts): 调用了 puts 函数，打印了字符串 "Hello World!"。
	la.local $r4, .LC1: 将 .LC1 的地址加载到 $r4 寄存器。
	bl %plt(puts): 再次调用了 puts 函数，打印了字符串 "Welcome to LoongArch World!"。
	or $r12, $r0, $r0: 将 $r12 寄存器清零。
	or $r4, $r12, $r0: 将 $r4 寄存器清零。
	ld.d $r1, $r3, 8: 从栈中加载先前存储的 $r1 寄存器的值。
	ldptr.d $r22, $r3, 0: 从栈中加载先前存储的 $r22 寄存器的值。
	addi.d $r3, $r3, 16: 增加 $r3 寄存器的值，恢复栈指针。
	jr $r1: 跳转到 $r1 寄存器所存的地址，结束程序运行。

```

![image.png](http://verification.fengzhongzhihan.top/202312252001372.png)

```la
这段代码看起来是一段汇编语言的数据段定义，它定义了一些变量和字符串，每个变量都有不同的数据类型和初始值。让我来解释一下这段代码的含义：

1. `.data 0x10012000`: 这是数据段的开始地址，表明数据将从内存地址 `0x10012000` 开始存放。

2. `str1: .ascii “SDUCS”`: `str1` 是一个ASCII字符串变量，存储了字符序列 "SDUCS"，每个字符占用一个字节。

3. `str2: .asciiz “SDUCS2022”`: `str2` 也是一个ASCII字符串变量，存储了以 "SDUCS2022" 结尾的字符串，其中每个字符占用一个字节。`.asciiz` 指示字符串以空字符(`\0`)结尾，即C语言风格的字符串。

4. `b1: .byte 1,2,3,4`: `b1` 是一个字节型变量，存储了四个字节的数据，分别是 1, 2, 3, 4。

5. `h1: .half 1,2,3,4`: `h1` 是一个半字（16位）型变量，存储了四个半字的数据，分别是 1, 2, 3, 4。

6. `w1: .word 1,2,3,4`: `w1` 是一个字（32位）型变量，存储了四个字的数据，分别是 1, 2, 3, 4。

总的来说，这段代码定义了一些不同类型的数据变量：
- 两个字符串变量 `str1` 和 `str2`，存储了不同的字符串。
- 四个不同大小的数值变量 `b1`（字节型）、`h1`（半字型）、`w1`（字型），它们分别存储了特定大小的整数值。
```
## 3.3 MIPS体系结构(RISC)
**背景**
GCC转化过程

![image.png|550](http://verification.fengzhongzhihan.top/202312271631813.png)
指令字：用来表示指令的一组二进制代码。
指令字长：指令中包含的二进制代码位数
机器字长：计算机能够直接处理的二进制数据的位数 = 寄存器的宽度。

定义 : 
Microcomputer without interlocked pipeline stages
### 3.3.1 寄存器
![image.png](http://verification.fengzhongzhihan.top/202309271058121.png)
注意
- MIPS没有状态码,CPU状态寄存器和内部都不包含任何结果状态信息
- hi和lo是乘法运算器相关的两个寄存器,比如前32位放在hi,后32位放在lo

### 3.3.2 指令格式RIJ三种类型

**R型**
![image.png|425](http://verification.fengzhongzhihan.top/202309271125466.png)
![image.png|500](http://verification.fengzhongzhihan.top/202312271703931.png)

举例
9+10 的结果放入8号寄存器
![image.png|450](http://verification.fengzhongzhihan.top/202309271127323.png)

**I型**
![image.png|475](http://verification.fengzhongzhihan.top/202309271130181.png)
![image.png|475](http://verification.fengzhongzhihan.top/202312271704821.png)


举例:22-50 存入21寄存器
![image.png|450](http://verification.fengzhongzhihan.top/202309271131553.png)

**J型**
![image.png|475](http://verification.fengzhongzhihan.top/202309271132797.png)


%% ### 3.3.3 协处理器
![image.png|575](http://verification.fengzhongzhihan.top/202309271135068.png)
CP0:最重要 %%
### 3.3.3 寻址方式
R型指令：由op和func字段共同隐含说明当前的寻址方式。
I型和J型指令：由op字段隐含说明当前指令使用的寻址方式。

立即数寻址
![image.png|325](http://verification.fengzhongzhihan.top/202309271147849.png)

寄存器直接寻址
![image.png|350](http://verification.fengzhongzhihan.top/202309271148038.png)

基址寻址
![image.png|425](http://verification.fengzhongzhihan.top/202309271148595.png)

PC相对寻址
![image.png|450](http://verification.fengzhongzhihan.top/202309271148949.png)

伪直接寻址
![image.png|425](http://verification.fengzhongzhihan.top/202309271149986.png)
### 3.3.4 指令类型
#### 3.3.4.1 整数算术指令
加减法
![image.png|475](http://verification.fengzhongzhihan.top/202310111049222.png)

注意乘法和除法
![image.png|475](http://verification.fengzhongzhihan.top/202309271151071.png)
![image.png|475](http://verification.fengzhongzhihan.top/202309271152880.png)
若有浮点数,则在开头加上d

除法
- 商->L, 余->H
- mflo $v0 : 代表从低位取数放入了v0
乘法
- 低->L, 高->H

**例题**
![image.png|375](http://verification.fengzhongzhihan.top/202309271154941.png)

move from low :取商放入v0
jr:返回地址放入ra
#### 3.3.4.2 逻辑运算指令
![image.png|375](http://verification.fengzhongzhihan.top/202310111057050.png)
![image.png|375](http://verification.fengzhongzhihan.top/202310111058645.png)
![image.png|375](http://verification.fengzhongzhihan.top/202310111059063.png)
![image.png|375](http://verification.fengzhongzhihan.top/202310111111084.png)
![image.png|475](http://verification.fengzhongzhihan.top/202310111111575.png)
例如，对于二进制数 10101101，循环右移一位将得到 11010110。
例如，对于二进制数 10101101，循环左移一位将得到 01011011。

**例题**

![image.png|475](http://verification.fengzhongzhihan.top/202310111126309.png)
![image.png|400](http://verification.fengzhongzhihan.top/202310111132979.png)
![image.png](http://verification.fengzhongzhihan.top/202309251755691.png)
```mips
.data
    input:  .word 0xAABB
    output: .word 0

.text
    lw $t0, 0xAABB       # 将输入数据加载到寄存器$t0
    srl $t1, $t0, 8     # 将$t0右移8位，即取得高位字节AA
    sll $t2, $t0, 8     # 将$t0左移8位，即取得低位字节BB
    or $t3, $t1, $t2    # 将高位字节和低位字节进行逻辑或操作
    sw $t3, output      # 将结果保存到output变量中

```
#### 3.3.4.3 装载与存储指令

![image.png|475](http://verification.fengzhongzhihan.top/202312271746715.png)

![image.png|425](http://verification.fengzhongzhihan.top/202310111148226.png)

#### 3.3.4.4 跳转和分支指令

![image.png](http://verification.fengzhongzhihan.top/202312271746374.png)
![image.png](http://verification.fengzhongzhihan.top/202312271748324.png)

注意点:

#### 3.3.4.5 分支指令

![image.png](http://verification.fengzhongzhihan.top/202312271748357.png)

#### 3.3.4.6 比较指令
![image.png](http://verification.fengzhongzhihan.top/202312271749241.png)

#### 3.3.4.7 补充

![image.png|475](http://verification.fengzhongzhihan.top/202312271810316.png)

**例题**

![image.png|425](http://verification.fengzhongzhihan.top/202312271750862.png)

![image.png|450](http://verification.fengzhongzhihan.top/202312271751187.png)
![image.png|425](http://verification.fengzhongzhihan.top/202312271757258.png)

### 3.3.5 异常处理

在MIPS32架构中，有一些事件要打断程序的正常执行流程，这些事件有中断，陷阱，系统调用以及其他任何可以打断程序正常执行流程的情况，统称为异常。

常见异常
- 硬件复位
- 中断（包括软中断，硬中断）
- syscall系统调用
- 无效指令
- 溢出
- 自陷指令引发的异常


1. 检查CP0中status寄存器的EXL字段，分两种情况：
- 如果EXL为1，表示当前已经处于异常处理过程中了，此时
	- 如果当前发生的异常类型是中断，那么不处理，忽略该异常，因为在异常处理过程中会禁止中断。
	- 如果当前发生的异常类型不是中断，那么将异常原因保存到CP0中的cause寄存器的ExeCode字段，转到步骤（4）
- 如果EXL为0，那么将异常原因保存到CP0中cause寄存器的ExeCode字段，进入步骤（2）
2. 检查发生异常的指令是否在延迟槽中
	- 如果在延迟槽中，那么设置EPC寄存器的值为该指令的地址减4，同时设置cause寄存器的BD字段为1
	- 如果不在延迟槽中，设置EPC寄存器的值为该指令的地址，同时设置cause寄存器的BD字段为0.
3. 设置status寄存器的EXL字段为1，表示进入异常处理过程，禁止中断。
4. 处理器转移到事先定义好的一个地址(异常处理例程入口地址)，在那个地址中往往有异常处理的程序，在其中进行异常处理
![image.png|650](http://verification.fengzhongzhihan.top/202311212308102.png)
### 3.3.6 系统调用

![image.png|525](http://verification.fengzhongzhihan.top/202312271806400.png)


syscall的系统调用号
![image.png|575](http://verification.fengzhongzhihan.top/202311212311692.png)

例:**输出helloworld**
write系统调用的c原型为：
   ssize_t write(fd, const void * buf, size_t count);
- fd为文件描述符，输出到屏幕为STDOUT = 1
  - buf为字符串地址
  - count为字符串长度

![image.png|475](http://verification.fengzhongzhihan.top/202311212316576.png)



**输入输出数组**

read 文件读取调用，C语言原型为：
  ssize_t read(int fd, void *buf, size_t count)

   参数意义为：
   fd为文件描述符,从键盘读fd=STDIN=0
   buf为输出缓冲区
   count为试图读取的字节数
   返回值为实际读取的字节数（可以检查$v0寄存器）

思考：读取姓名并在屏幕打印

打印数组
![image.png](http://verification.fengzhongzhihan.top/202311212316612.png)
![image.png](http://verification.fengzhongzhihan.top/202311212319346.png)

# 4 程序的加载和运行

## 4.1 linux下的可执行文件
Linux下的目标文件格式为ELF (Executable and Linkable Format)是**一种为可执行文件，目标文件，共享链接库和内核转储(core dumps)准备的标准文件格式**
- .test:  所有代码放在同一个节里面
- .data: 所有已初始化的数据
- .bss:所有未初始化的数据
- .rodata: 只读数据
- ELF header(最重要):存放了节表,保存了所有节的基本属性, 包括每个节的节名、节在ELF文件中的偏移、节的长度及节的读写权限等，节表决定了整个ELF文件的结构。

%% 将数据分节的好处
1. 便于进行区分
2. 便于给节设置读写权限，有的节只需要设置只读权限
3. 方便CPU缓存的生效
4. 有利于节省内存，例如程序有多个副本情况下，此时只需要一份代码段即可 %%
## 4.2 虚拟存储
**虚拟存储器**是指具有请求调入功能和置换功能,能从逻辑上对内存容量加以扩充的一种存储技术。运行速度接近于内存速度而每位的成本却接近于外存。

在指令执行时，处理器产生一个**虚拟地址**，并不真实存在于计算机内存中，它是物理地址的映射。这个地址被硬件和软件的组合即存储器管理部件（MMU)，转换为一个物理地址，来访问主存内容。

**虚拟内存优点**
- 便于管理。每个进程拥有一致的虚拟存储空间，可以简化管理。
- 节约物理内存。无需将程序全部装入内存，仅在需要特定页时，动态加载到物理空间。
- 隐藏和保护。各个进程的虚拟存储空间私有，相互之间不会影响。
## 4.3 运行
操作系统内核首先需将程序装入内存中才可执行程序
- 需要加载器(loader来加载可执行文件到内存)
- 加载方式
	- 静态装入：程序被全都装入内存中，要求物理内存大小要大于程序所需的空间大小。
		- 实现简单但是空间利用率低，代价昂贵。
	- 动态装入：程序的运行具有空间和时间上的局部性，所以我们可以将程序当前最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里面，等到需要时将数据调入内存。
		- 覆盖装入:程序员操作
		- 页映射:操作系统处理

**页映射步骤**(程序动态装进内存)
1. 准备阶段 : 创建虚拟空间。由页映射函数将虚拟空间映射到内存物理空间.
2. 准备阶段 : 读取exe文件的header，并且建立虚拟空间与可执行文件的映射关系。
3. 在相关的映射建立之后，操作系统将CPU的指令寄存器设置成可执行文件的入口地址，启动运行。此时无法找到内存中的可执行程序,发生缺页错误,经过以下步骤，将所需页调入物理空间，进程继续执行
	1. CPU将控制权交给操作系统
	2. 操作系统通过虚拟空间与可执行文件的映射(磁盘中)找到所需页的位置，从物理空间中分配一个页，将缺页调入内存
	3. 设置缺页的虚拟页和物理页之间的联系
	4. 控制权交还进程，进程继续运行
4. 执行过程
	1. 操作系统在创建进程之后，跳转到这个进程的入口函数
	2. 入口函数对程序运行环境进行初始化，包括堆、I/O、线程、全局变量的构造等
	3. 入口函数在完成初始化之后，调用main() 函数，开始执行程序的主体
	4. main() 函数执行完毕之后返回到入口函数，入口函数进行清理工作，最后通过系统调用结束进程。

## 4.4 装载ELF文件(SHELL)
1.  execve()
	当shell中键入执行程序的指令之后，shell进程获取到键入的指令，并执行execve()函数
	- 参数 : 键入的可执行文件名,形式参数，环境变量信息
	- execve()函数对进程栈进行初始化，即压栈环境变量值，并压栈传入的参数值，最后压栈可执行文件名
2.  sys_execve()
	该函数进行一些参数的检查与复制
3. do_execve()
	该函数在当前路径与环境变量的路径中寻找给定的可执行文件名，找到文件后读取该文件的前128字节,为了判断文件的格式，每个文件的开头几个字节都是魔数，可以用来判断文件类型。
4. search_binary_handle()
	该函数将去搜索和匹配合适的可执行文件装载处理程序。Linux 中所有被支持的可执行文件格式都有相应的处理程序。以Linux 中的ELF 文件为例，接下来将会调用elf 文件的处理程序：load_elf_binary()。
5. load_elf_binary()
	1. 创建虚拟地址空间：实际上指的是建立从虚拟地址空间到物理内存的映射函数所需要的相应的数据结构（即创建一个空的页表）；
	2. 读取可执行文件的文件头，建立可执行文件到虚拟地址空间之间的映射关系；
	3. 将CPU指令寄存器设置为可执行文件入口（虚拟空间中的一个地址）。
6. 程序返回到execve()中

	此时从内核态返回到用户态，且寄存器的地址被设置为了ELF的入口地址，于是新的程序开始启动，发现程序入口对应的页面并没有加载（因为初始时是空页面），此时引发一个缺页错误，操作系统根据可执行文件和虚拟内存之间的映射关系，在磁盘上找到缺的页，并申请物理内存，将其加载到物理内存中，并在页表中填入该虚拟内存页与物理内存页之间的映射关系。之后程序正常运行，直至结束后回到shell父进程中，结束回到shell。
	

## 4.5 流水线
流水线提高了模型制造过程的吞吐率，如果有足够多的模型制造任务，那么虽然制造单个模型的时长没有缩减，但它减少了完成任务的总体时间。

衡量流水线的加速效果
**加速比=不使用流水线的执行时间/使用流水线的执行时间**

在生产玩具模型的例子中，我们可以假设模型制造的每个阶段占用的时长相等，同时我们有足够多的任务需要去完成。这种情况下，因为同一时刻在执行4个任务，所以总体加速比会无限接近于4

执行程序时步骤
1. 取指令阶段：取指令阶段是将一条指令从主存中取到指令寄存器的过程。程序计数器PC中的数值，用来指示取出指令在主存中的位置。当一条指令被取出后， (PC) + 1= PC形成下条指令地址。(取指令)
2. 指令译码阶段：指令译码阶段，指令译码器按照预定的指令格式，对取回的指令进行拆分和解释，识别区分出不同的指令类别以及各种获取操作数的方法。(需要读寄存器)
3. 指令执行阶段：完成指令所规定的各种操作，具体实现指令的功能。(ALU操作)
4. 访存阶段：根据指令地址码，得到操作数在主存中的地址，并从主存中读取该操作数用于运算。(数据存取, 访问内存)
5. 结果写回阶段：把执行指令阶段的运行结果数据写回到某种存储部件。(写寄存器)

## 4.6 指令流水线
指令流水线是一种实现多条指令重叠执行的技术。一条指令的执行一般需要经过多步操作，每个操作与其他操作之间可以同时执行，而流水线方式能够充分利用这些操作之间的并行性。

以RISC指令集中的LoongArch指令集为例。在LoongArch指令集中，一条指令的执行可以分为以下五步操作，分别是：
**取指,译码,执行,访存,写回**

![image.png](http://verification.fengzhongzhihan.top/202401041451871.png)

因此在理想情况下，流水线的加速比能够达到5。

指令流水线的**加速比无法达到理想值**
- 原因是实际指令运行过程中，每个阶段的运行时间有长有短，时钟周期的时长需满足最慢的阶段

例题
![image.png](http://verification.fengzhongzhihan.top/202311221002691.png)

1. 在单周期指令模型中，一个时钟周期执行一条指令，因此时钟周期的时间长度必须满足最慢的指令。在我们考虑的四条指令中，最慢的是取字（ld.w）指令，总时长为800ps，因此时钟周期应设置为800ps。
（2）与单周期指令模型类似，指令流水线的时钟周期必须要满足最慢的步骤，在指令执行的五个步骤中，耗时最长的是存储器的存取和ALU操作，均为200ps，因此指令流水线的时钟周期为200ps。

![image.png](http://verification.fengzhongzhihan.top/202311221009811.png)

（3）如图所示，单周期指令模型执行单条指令的时间为800ps，因此执行3条指令所需时间为2400ps。在指令流水线中，一个时钟周期执行指令周期中的一个子过程，所需时间为200ps，因此执行一条指令所需时间为1000ps。执行3条指令所需时间为1400ps。因此，加速比为2400/1400≈1.7，这里加速比较小的原因是流水线未填满，同时由于指令流水线的时钟周期需要考虑最慢的步骤，因此指令流水线下单条指令的执行时长为1000ps，大于单周期指令模型800ps的单条指令执行时间。
（4）如果执行无数条指令，理想情况下加速比为多少？
    解：首先考虑将指令数量与执行时间联系起来，假设指令数量为n，那么单周期指令模型中，指令的执行时间为（时钟周期 * 指令数量）＝ 800 * n；在指令流水线中，由于除了第一条指令需要1000ps外，每增加一条指令，执行时间增加200ps，因此指令的执行时间为1000+200（n-1）= 800＋200 * n。因此，当n趋于无穷时，加速比为(800∗𝑛)/(800＋200∗𝑛)

## 4.7 流水线问题

**冒险**
定义 : 在下一个时钟周期内，待执行指令无法正常执行
原因 : 若继续按指令流水线的方式来执行指令，可能会导致不正确的计算结果。

### 4.7.1 数据冒险
指的是，一条指令的执行需要使用前一条指令的运行结果，但是这个运行结果还没有被写回。

常见依赖
写后读（Read After Write，RAW）依赖, (最为常见)
读后写（Write After Read，WAR）依赖, 
写后写（Write After Write，WAW）依赖。

在我们的指令流水线过程中，如果指令不是乱序执行，就只会遇到RAW的数据冲突，当然，如果指令是乱序执行，即不按照原本顺序执行，那么以上三种冲突都有可能发生。

举例
![image.png](http://verification.fengzhongzhihan.top/202401041512213.png)


**解决方法**
阻塞
- 为了保证指令的正确执行，最直接的解决办法就是阻塞下一条指令，让第2条指令等待3个时钟周期，这样等待第1条指令将结果写入寄存器，第2条指令才开始读取寄存器内容。
- 流水线阻塞的具体实现方式称为气泡（Bubble），即阻止寄存器内容改变并通知下一级流水线指令无效，因此流水线阻塞有时又会被称为气泡。

![image.png](http://verification.fengzhongzhihan.top/202311242024211.png)


前递(旁路)
- 从内部资源中直接提前得到缺少的运算项。
- 在这种情况下，我们将原本3个时钟周期的延迟减少到1个时钟周期，大大提高了指令流水线的效率，减少了数据冒险所带来的影响。
![image.png](http://verification.fengzhongzhihan.top/202401041516506.png)

### 4.7.2 控制冒险

控制冒险（Control hazard）
指的是尚未确定是否发生的分支指令(if)，如何进行下一次取指的问题。

图中表示了分支指令beq会出现的控制冒险。当分支指令beq经过执行阶段，才能得出下一条指令的执行地址并将它输入程序计数器PC，但是此时指令流水线已经取回下一条指令，这时就可能导致取回错误的指令。

![image.png](http://verification.fengzhongzhihan.top/202401041517929.png)


**解决控制冒险的方法**

阻塞

预测（Prediction）
- 在预测正确的情况下不会降低流水线的效率，但在预测错误的情况下，需要回到预测错误的位置重新执行正确的分支。
- 分支预测有多种，最简单一种就是总预测分支未发生，这样当预测正确时，流水线就会正常执行，只有当转移发生时才会产生阻塞。还有更加成熟的技术称为动态分支预测，它的预测会基于本身及其他分支跳转的历史记录，并且会动态改变分支预测结果。这种情况下，分支预测的成功率能够达到90%以上。

### 4.7.3 结构冒险
结构冒险（Structure Hazard）指的是，硬件不支持多条指令在同一时钟周期内执行的情况。假设并行的两个阶段申请同一硬件资源，就会导致资源的抢夺，那么在这个时钟周期内，总有一方申请的资源无法得到满足，这种情况就会导致结构冒险。

结构冒险最经常发生在功能单元未能完全流水化的情况下，因此此时的功能单元不能满足每个时钟周期执行一条指令；或者某一资源不足以满足流水线中的指令组合，比如寄存器只有一个写端口，但是指令想在一个时钟周期内写两次。

**解决方法**
阻塞

如果结构冒险很少发生，那么就不必耗费大量成本来避免它。
当然，对于某些发生频率较高的结构冒险，最好的解决方式是**增加资源数量**，当资源数量能够满足需求，阻塞的频率就会大大降低。

指令3执行的时候, 指令2的取指的时候, 占用了PC, 此时不能继续进行取指操作
![image.png|525](http://verification.fengzhongzhihan.top/202311221028461.png)

%% ### 4.7.4 异常

异常通常被分为可恢复异常和不可恢复异常：

不可恢复异常通常发生在出现严重的系统硬件错误时
- 立即终止当前的执行，记录软件所需的信息，然后跳转到异常处理入口即可。

可恢复异常的处理比较困难
- 发生异常的指令前面的所有指令都执行完成，而发生异常的指令后面的所有指令都没有执行。(精确异常)

**异常处理**
流水线处理器中，这些不同类型的异常可能发生在流水线的不同阶段，所以实现精确异常需要设计详细的异常处理机制。以下给出一个例子：

1. 当某一级流水发生异常时，在流水线中记录发生异常的事件，等到写回阶段再处理；

2. 如果在执行阶段要修改机器状态（如状态寄存器），保存下来直到写回阶段再修改；

3. 指令的PC值随指令流水前进到写回阶段为异常处理专用；

4. 将外部中断作为取指的异常处理；

5. 指定一个通用寄存器(或一个专用寄存器)为异常处理时保存PC值专用；

当发生异常的指令处在写回阶段时，保存该指令的PC及必需的其他状态,置取指的PC值为异常处理程序入口地址。 %%

%% ## 4.8 流水线优化

**衡量指标**

衡量指标
当我们衡量处理器的性能时，通常会用到CPI(Clock cycle Per Instruction)，它表示每条计算机指令执行所需的时钟周期，我们规定

CPI=执行程序所需的时钟周期数/所执行的指令条数

一个**流水化处理器的CPI**等于理想CPI和冒险产生的阻塞耗费的周期之和：
流水线CPI=理想CPI+结构冒险阻塞+数据冒险阻塞+控制冒险阻塞

从上述公式可知，当我们想要提高流水线处理器的性能时，可以从以下两个角度入手：降低理想CPI，或者降低各种冒险带来的阻塞。

- 多发射数据通路
	- 它的思想是让每一级流水线能够处理更多的指令。
- 动态调度
	- 如果我们能动态地改变指令的执行顺序，让不相关的指令先执行
- 转移预测
	- 为了降低转移指令带来的延迟，一种常见的处理方式是采用硬件转移预测机制，转移预测有时又称为分支预测，现代处理器普遍采用这种方式来解决控制冒险带来的阻塞。 %%


# 5 数据表示

总览

![image.png](http://verification.fengzhongzhihan.top/202401041532657.png)

## 5.1 表示三要素


![image.png](http://verification.fengzhongzhihan.top/202401041543001.png)

## 5.2 整数

### 5.2.1 无符号数编码
- 所有的位都可以参与运算
- 表示范围0 ~ 2 ^ n - 1 

### 5.2.2 有符号数编码
机器数 : 有符号数在计算机中二进制的数据
真值 : 机器数对应的真正的数据

原码定义
![image.png|475](http://verification.fengzhongzhihan.top/202310301653686.png)

优点 : 简单易懂，即符号位加上真值绝对值的二进制数，与真值的对应关系直观。
缺点 : 
（1）0的表示不唯一，给使用带来了不便。
（2）运算过程复杂。进行加法运算时，首先要判断两数是否同号，同号则相加，异号则相减；进行减法运算时，先要比较两个数的绝对值大小，然后使用绝对值大的数减去绝对值小的数，最后还要赋予结果正确的符号。

补码定义
![image.png|450](http://verification.fengzhongzhihan.top/202310301656734.png)

表示
![image.png|575](http://verification.fengzhongzhihan.top/202310301656115.png)
![image.png](http://verification.fengzhongzhihan.top/202310301657924.png)

反码定义
![image.png|475](http://verification.fengzhongzhihan.top/202310301659090.png)
相比补码仅仅末尾 - 1 

移码定义
![image.png](http://verification.fengzhongzhihan.top/202310301701585.png)
- 也就是在真值上加上偏移量常数2 ^ n 
- 可以从移码形式上判断真值大小
![image.png](http://verification.fengzhongzhihan.top/202401041558724.png)

逻辑和算数右移
- 逻辑:补0
- 算数:补符号位
## 5.3 浮点数

引例 : 身份证号码含义表示

![image.png|450](http://verification.fengzhongzhihan.top/202401041559961.png)


### 5.3.1 定义和范围

浮点数的表示
![image.png](http://verification.fengzhongzhihan.top/202310301646290.png)

![image.png|700](http://verification.fengzhongzhihan.top/202310301640926.png)

### 5.3.2 规格化
IEEE 754标准
- 32位浮点格式和64位浮点格式

![image.png](http://verification.fengzhongzhihan.top/202310301625082.png)
- 默认小数点后的第一位为1,因此23,52位尾数可以多表示一位的有效数据
- 尾数用原码表示(为正数),阶码用移码表示:可以不用区分有符号数和无符号数
- 移码的偏置常数为127和1023

![image.png](http://verification.fengzhongzhihan.top/202401041609872.png)


例题转换
![image.png|500](http://verification.fengzhongzhihan.top/202310301638452.png)

![image.png|375](http://verification.fengzhongzhihan.top/202310301638724.png)


## 5.4 非数值型数据
### 5.4.1 逻辑数据
- 用来表示若干个状态位或控制位
- 运算
- 识别
### 5.4.2 西文字符
常用编码:7位ASCII码
所有字符总数不超过256个，使用7或8个二进位可表示
操作:字符串比较
### 5.4.3 汉字
编码形式
- 输入码, 对汉字用相应按键进行编码表示，用于输入
- 内码, 用于在系统中进行存储、查找、传送等处理
- 字模点阵或轮廓描述 : 描述汉字字模点阵或轮廓，用于显示/打印

>至少需要2个字节才能表示一个汉字内码 : 由汉字总数决定
>可在GB2312国标码的基础上产生汉字内码
为与ASCII码区别，将国标码的两个字节的第一位置“1”后得到一种汉字内码

>西文字符也有输入码,内码,字模点阵或轮廓描述

为便于打印、显示汉字，汉字字形必须预先存在机内
- 字库 (font)：所有汉字形状的描述信息集合
- 不同字体 (如宋体、仿宋、楷体、黑体等) 对应不同字库
- 从字库中找到字形描述信息，然后送设备输出
>如何知道到哪里找相应的字形信息？汉字内码与其在字库中的位置有关！！



## 5.5 数据的存储和排序

数据存储
- 大端模式:低地址存高字节
- 小端模式:低地址存低字节

例:int a=01 23 45 67
- 大端01(MSB)存
- 小端67(LSB)存

例子:
0x12345

![image.png](http://verification.fengzhongzhihan.top/202401041626853.png)
左小端右大端
- 指令0x12345表示 高位为01 
- 小端 : 将低位45放到低位 45 23 01 00

对齐存储
![image.png](http://verification.fengzhongzhihan.top/202401041631973.png)

![image.png](http://verification.fengzhongzhihan.top/202401041632661.png)

读取器读数据的方式是四字节对齐读

## 5.6 例题

![image.png](http://verification.fengzhongzhihan.top/202401041645810.png)

```answer
这些问题涉及数字表示法和计算机算术运算的理论，我会逐个解答你提出的问题。

补码 1x1x2x3x4x5  则 -x1-x2-x3-x4-x5  > 01111
则x1一定为0, 其余随意

3. 若[𝑥]_补>[𝑦]_补，则讨论是否有𝑥>𝑦。
   - 解:若[x]补>[y]补,不一定有x>y。 [x]补 > [y]补时 x > y的结论只在 x > 0、y > 0,及 x<0、y<0时成立。当x>0、 y<0时,有x>y,但由于负数补码的符号位为1,则[x]补<[y]补。同样,当x<0、 y >0时,有x < y,但[x]补>[y]补。

4. 使用原码加减交替法计算𝑥÷𝑦。
   - (1) 𝑥=+11010，𝑦=+1101
     - 此处求的是商，应使用除法。商等于商的绝对值，乘除法不受符号影响。所以11010/1101 = 10（二进制表示）。正数10的原码为+0010，即商为+0010。
   - (2) 𝑥=+10010，𝑦=－1001
     - 10010/-1001 = -10（二进制表示）。负数10的原码为-0010，即商为-0010。
   - (3) 𝑥=－10010，𝑦=＋1001
     - -10010/1001 = -10（二进制表示）。负数10的原码为-0010，即商为-0010。

5. 使用原码一位乘法计算𝑥∙𝑦。
   - (1) 𝑥=+11010，𝑦=+10101
     - 11010*10101 = 100111110（二进制表示）。正数100111110的原码为+01111110，即乘积为+01111110。
   - (2) 𝑥=+10010，𝑦=－10111
     - 10010*(-10111) = -11001110（二进制表示）。负数11001110的原码为-1001110，即乘积为-1001110。
   - (3) 𝑥=－10010，𝑦=＋10100
     - (-10010)*10100 = -101010000（二进制表示）。负数101010000的原码为-01010000，即乘积为-01010000。

6. 设机器字长为8位，求出采用1位和两位符号位能表示的数的范围。

在计算机中，字长是指一次可以处理的二进制位数。对于机器字长为8位，我们可以使用1位和2位符号位来表示数的范围。

1位符号位的情况下，有1位作为符号位，剩下的7位用来表示数值。这种情况下，最高位（符号位）可以表示正负数，因此可以表示的范围是：

27=12827=128

即可以表示-128到+127的整数。

而对于2位符号位，可以有2位用作符号位，剩下的6位用来表示数值。这种情况下，最高的两位可以表示正负数，所以可以表示的范围是：

26=6426=64

即可以表示-64到+63的整数。

所以，对于8位的机器字长：

- 1位符号位可以表示-128到+127的整数。
- 2位符号位可以表示-64到+63的整数。
```

# 6 层次结构存储系统
## 6.1 内存和外存
记忆单元(cell)
- 具有两种稳态的能够表示0/1的物理器件
- 例如电容

存储单元(Addressing Unit)
- 具有相同地址的位构成一个存储单元(一个字节)

存储体
- 所有存储单元构成

编址方式
- 字节编址,按字编址

存储器地址寄存器(MAR)
存储器数据寄存器(MDR)

**外存**
外存储器（简称外存或辅存）
存取速度慢
成本低、容量很大
不与CPU直接连接，先传送到内存，然后才能被CPU使用。
属于非易失性存储器，用于长久存放系统中几乎所有的信息


**内存**
内存储器（简称内存或主存）
存取速度快
成本高、容量相对较小
直接与CPU连接，CPU对内存中可直接进行读、写操作
属于易失性存储器(volatile)，用于临时存放正在运行的程序和数据

关系图
![image.png](http://verification.fengzhongzhihan.top/202401052153842.png)


>问题：主存中存放的是什么信息？CPU何时会访问主存？

指令及其数据！CPU执行指令时需要取指令、取数据、存数据！

>问题：地址译码器的输入是什么？输出是什么？可寻址范围多少？

输入是地址，输出是地址驱动信号（只有一根地址驱动线被选中）。
可寻址范围为0~2^36-1，即主存地址空间为64GB（按字节编址时）。
2^10 =1000, 1KB = 2^10 B 

![image.png](http://verification.fengzhongzhihan.top/202401052212296.png)


%% **按工作性质(存取方式分类)**
随机存取存储器(RAM)
- 每个单元读写时间一样,与各单元所在位置无关
- 如内存

顺序存取存储器(SAM)
- 读写时间与位置有关
- 如磁带

直接存取存储器(DAM)
- 直接定位数据块,顺序读取数据块
- 如磁盘

相联存储器(AM associate memory)
- 快表
 %%
## 6.2 磁盘存储器
磁头的读写
![image.png|500](http://verification.fengzhongzhihan.top/202401052214175.png)

1 : N-S
0 : S-N


磁盘的磁道和扇区
![image.png|475](http://verification.fengzhongzhihan.top/202311221425103.png)

综观
![image.png](http://verification.fengzhongzhihan.top/202401052217088.png)
磁道号就是柱面号、磁头号就是盘面号

**操作步骤**
所有磁头同步寻道（由柱面号控制）→ 选择磁头（由磁头号控制） → 被选中磁头等待扇区到达磁头下方（由扇区号控制） → 读写该扇区中数据
**平均存取时间**
T = 平均寻道时间 + 平均旋转等待时间 + 数据传输时间（忽略不计）——( 大约0.01ms / 扇区 )
平均寻道时间——磁头寻找到指定磁道所需平均时间(约5ms)

平均旋转等待时间——指定扇区旋转到磁头下方所需平均时间 
(约4～6ms)  ( 转速： 4200 / 5400 / 7200 / 10000rpm )


**组成**
磁记录介质：用来保存信息

磁盘驱动器：包括读写电路、读/写转换开关、磁头与磁头定位伺服系统等

磁盘控制器：包括控制逻辑、时序电路、“并→串”转换和“串→并”转换电路等。（用于连接主机与盘驱动器）
- 磁盘控制器连接在I/O总线上，I/O总线与其他总线（系统总线、存储器总线）之间用桥接器连接
![image.png](http://verification.fengzhongzhihan.top/202401052222997.png)

磁盘的最小读写单位是扇区

因此，磁盘按成批数据交换方式进行读写，采用直接存储器存取（DMA，Direct Memory Access）方式进行数据输入输出，需用专门的DMA接口来控制外设与主存间直接数据交换，数据不通过CPU。

通常把专门用来控制总线进行DMA传送的接口硬件称为DMA控制器

**读磁盘扇区的步骤**

需要CPU进行调控

1. CPU对磁盘控制器初始化:读命令,磁盘逻辑块号,主存起始地址
然后启动磁盘驱动器工作
2. 磁盘控制器读相应的扇区，并按DMA方式把数据送主存
3.  当DMA传送结束，磁盘控制器向CPU发出“DMA结束中断请求”，要求CPU进行相应的后处理。


**固态硬盘**
固态硬盘（Solid State Disk，简称SSD）也被称为电子硬盘。

它并不是一种磁表面存储器，而是一种使用NAND闪存组成的外部存储系统,相当于优化版U盘!

它用闪存颗粒代替了磁盘作为存储介质，利用闪存的特点，以区块写入和抹除的方式进行数据的读取和写入。

写操作比读操作慢得多。(还要回检查)

**电信号**的控制使得固态硬盘的**内部传输速率**远远高于常规硬盘。 

其接口规范和定义、功能及使用方法与传统硬盘完全相同，在产品外形和尺寸上也与普通硬盘一致。目前接口标准上使用USB、SATA和IDE，因此SSD是通过标准磁盘接口与I/O总线互连的。

在SSD中有一个闪存翻译层，它将来自CPU的逻辑磁盘块读写请求翻译成对底层SSD物理设备的读写控制信号。因此，这个闪存翻译层相当于磁盘控制器。 

闪存的擦写次数有限，所以频繁擦写会降低其写入使用寿命。 

## 6.3 层次结构
![image.png](http://verification.fengzhongzhihan.top/202311221436175.png)

SRAM (静态存储)更贵一些   DRAM(动态存储)

>为什么层次化结构有效>?

**因为程序访问局部化特点!**
原因:
- 指令：指令按序存放，地址连续，循环程序段或子程序段重复执行
- 数据：连续存放，数组元素重复、按序访问


时间局部性（Temporal Locality）
- 含义：刚被访问过的单元很可能不久又被访问
- 做法：让最近被访问过的信息保留在靠近CPU的存储器中
- 举例:循环  ,  同时对一个变量操作

空间局部性 （Spatial Locality）

- 含义：刚被访问过的单元的邻近单元很可能不久被访问
- 做法：将刚被访问过的单元的邻近单元调到靠近CPU的存储器中 
- 举例: 数组   代码顺序存放...

>为什么引入Cache可以加快访存速度

在CPU和主存之间设置一个快速小容量的存储器，其中总是存放最活跃（被频繁访问）的程序和数据，由于程序访问的局部性特征，大多数情况下，CPU能直接从这个高速缓存中取得指令和数据，而不必访问主存

**举例:**

```c
sum = 0;
for (i = 0; i < n; i++)
	sum += a[i];
*v = sum;
```

对应的汇编语言
```c
I0:		sum  <-- 0
I1:		ap  <-- A   A是数组a的起始地址
I2:		i   <-- 0
I3:		if (i >= n) goto done
I4:	loop: t   <-- (ap) 数组元素a[i]的值 
I5:		sum <-- sum + t   累计在sum中
I6:		ap  <-- ap + 4   计算下个数组元素地址
I7:		i   <-- i + 1  
I8:		if (i < n) goto loop
I9:	done:	V  <-- sum   累计结果保存至地址v

```

则指令和数据的时间局部性和空间局部性各自体现在哪里？
- 指令:若n足够大，则在一段时间内一直在局部区域内执行指令，故循环内指令的时间局部性好；按顺序执行，故程序空间局部性好！
- 数据:数组元素按顺序存放，按顺序访问，故空间局部性好；

每个数组元素都只被访问1次，故没有时间局部性。

以下哪个对数组a引用的空间局部性更好？时间局部性呢？
变量sum的空间局部性和时间局部性如何？
对于指令来说，for循环体的空间局部性和时间局部性如何？
![image.png|300](http://verification.fengzhongzhihan.top/202311221447264.png)

对于程序A而言:
- 数组a的空间局限性好,时间局部性差
	- 访问顺序与存放顺序一致
- sum:单个变量不考虑空间局部性, 每次都要遍历因此时间局部性好
- for: 空间局部性好,时间局部性好
	- 循环体内指令按序连续存放，所以空间局部性好！  
     循环体被连续重复执行2048x2048次，所以时间局部性好！


对于B而言
- 只有数组a不一样, 空间局限性差

## 6.4 Cache详解

在CPU和主存之间设置一个快速小容量的存储器，其中总是存放最活跃（被频繁访问）的程序和数据，由于程序访问的局部性特征，大多数情况下，CPU能直接从这个高速缓存中取得指令和数据，而不必访问主存。

Cache是一种小容量高速缓冲存储器，它由SRAM组成。
Cache直接制作在CPU芯片内，速度几乎与CPU一样快。
程序运行时，CPU使用的一部分数据/指令会预先成批拷贝在Cache中，Cache的内容是主存储器中部分内容的映象。

当CPU需要从内存读(写)数据或指令时，先检查Cache，若有，就直接从Cache中读取，而不用访问主存储器。

![image.png|475](http://verification.fengzhongzhihan.top/202311221450857.png)

存在问题:
>	如何分块？
主存块和Cache之间如何映射?
Cache已满时，怎么办？
写数据时怎样保证Cache和主存的一致性？
如何根据主存地址访问到cache中的数据？……

注意:cache对程序员(编译器)时是透明的, 感知不到cache的存在

什么是Cache的映射功能？
- Cache槽比主存块少，多个主存块映射到一个Cache槽中

如何进行映射？
- 把主存空间划分成大小相等的主存块（Block）
- Cache中存放一个主存块的对应单位称为槽（Slot）或行（line有书中也称之为块（Block）

### 6.4.1 **映射方式**
直接(Direct)：每个主存块映射到Cache的固定行
全相联(Full Associate)：每个主存块映射到Cache的任一行
组相联(Set Associate)：每个主存块映射到Cache固定组中任一行


**直接映射**Direct  Mapped Cache

把主存的每一块映射到一个固定的Cache行（槽）,也称模映射(Module Mapping)
映射关系为：
 Cache行号=主存块号 mod Cache行数
   举例：4=100 mod 16  （假定Cache共有16行）
	(说明：主存第100块应映射到Cache的第4行中。)

**特点**
容易实现，命中时间短
但不够灵活，Cache存储空间得不到充分利用，命中率低
  例如，需将主存第0块与第16块同时复制到Cache中时，由于它们都只能复制到Cache第0行，即使Cache其它行空闲，也有一个主存块不能写入Cache。这样就会产生频繁的 Cache装入。

假定数据在主存和Cache间的传送单位为512字。
Cache大小：2^13字=8K字=16行 x 512字/ 行
 主存大小：220字=1024K字=2048块 x 512字/ 块

![image.png](http://verification.fengzhongzhihan.top/202311271702465.png)


此时cache的构成
![image.png|450](http://verification.fengzhongzhihan.top/202311221535150.png)
  V为有效位，为1表示信息有效，为0表示信息无效
  开机或复位时，使所有行的有效位V=0
  某行被替换后使其V=1
  某行装入新块时 使其V=1

![image.png|450](http://verification.fengzhongzhihan.top/202311221536462.png)

计算容量
![image.png|475](http://verification.fengzhongzhihan.top/202311221539230.png)

**全相联映射**

![image.png](http://verification.fengzhongzhihan.top/202311271713921.png)

每次都要比较tag是否相同
![image.png|525](http://verification.fengzhongzhihan.top/202311271715322.png)

**组相联映射**

组相联映射结合直接映射和全相联映射的特点
将Cache所有行分组，把主存块映射到Cache固定组的任一行中

也即：组间模映射、组内全映射。映射关系为：

 Cache组号=主存块号 mod Cache组数
 举例：假定Cache划分为：8K字=8组x2行/组x512字/行 
 4=100 mod 8
 (主存第100块应映射到Cache的第4组的任意行中。)

结合直接映射和全相联映射的优点
- 当Cache组数为1时，变为全相联映射；
- 当每组只有一个槽时，变为直接映射

![image.png](http://verification.fengzhongzhihan.top/202401052320318.png)


### 6.4.2 效率
hit: 访问信息在cache 中
- hit rate = P(in cache)  用α表示
- hit time= time(in cache)

miss
- miss rate = 1-hit rate
- miss penalty = time (in memory)

plus : hit time<< miss penalty

$t_{avg}=αt_c+(1-α)(t_c+t_m)=t_c+(1-α)t_m$

访问速度和命中率关系很大!

**三种映射方式的影响**

- 直接: 平均最低
- 全相联: 命中率平均最高
- N-路组相联映射:居中

0 16 0 16 0 16  0 16 0 16
- 访存: 直接 hit rate=0!  全相联  8/10 =0.8

**替换算法**
- FIFO( first in first out)
- LRU (least - recently - used)
- LFU(least - frequently -used)
- Random

cache越大,miss率越低!
block 大小中间最好!

颠簸
- 当分块局部化范围(即：某段时间集中访问的存储区)超过了Cache存储容量时，命中率变得很低。极端情况下，假设地址流是1,2,3,4,1 2,3,4,1……，而Cache每组只有3行，那么，不管是FIFO，还是LRU算法，其命中率都为0。
### 6.4.3 一致性
因为Cache中的内容是主存块副本，当对Cache中的内容进行更新时，就存在Cache和主存如何保持一致的问题

一些情况
- 当多个设备都允许访问主存时
   例如：I/O设备可直接读写内存时，如果Cache中的内容被修改，则I/O设备读出的对应主存单元的内容无效；若I/O设备修改了主存单元的内容，则Cache中对应的内容无效。
- 当多个CPU都带有各自的Cache而共享主存时
   某个CPU修改了自身Cache中的内容，则对应的主存单元和其他CPU中对应的内容都变为无效。

对于写命中，有两种处理方式
- Write Through: 同时写Cache和主存单元,使用写缓冲（Write Buffer）
- Write Back :只写cache不写主存，缺失时一次写回，每行有个修改位（“dirty bit-脏位”）
	- 常用

对于写不命中，有两种处理方式
- Write Allocate (写分配) 将主存块装入Cache，然后更新相应单元.试图利用空间局部性，但每次都要从主存读一个块
	- 常用
- Not Write Allocate (非写分配) 直接写主存单元，不把主存块装入到Cache


### 6.4.4 cache数目
外部cache: 与cpu独立
片内cache: 与CPU同一个芯片

单级cache: 只用一个片内cache
多级cache: 同时使用L1 Cache和L2 Cache，甚至有L3 Cache，L1 Cache更靠近CPU，其速度比L2快，其容量比L2小

分立cache: 数据指令分开
联合cache: 数据指令放一块

cache命中率主要由程序的空间局部性和时间局部性决定
## 6.5 虚拟地址

早期：程序员自己管理主存，通过分解程序并覆盖主存的方式执行程序

目的：把程序员从大量繁琐的存储管理工作中解放出来，使得程序员编程时不用管主存容量的大小。

基本思想：把地址空间和主存容量的概念区分开来。程序员在地址空间里编写程序，而程序则在真正的内存中运行。由一个专门的机制实现地址空间和实际主存之间的映射。

程序员编写程序的空间（地址空间，可寻址空间）比执行程序的空间（主存容量）大得多，怎么自动执行程序呢？

![image.png|475](http://verification.fengzhongzhihan.top/202311271720734.png)

CPU传输的是虚拟地址
Cache输入的是物理地址
- 若是虚拟地址,则可能重合

将虚拟地址映射到物理地址上去!
- 每个虚拟地址对应了唯一的物理地址

### 6.5.1 分页

内存分成存储块（页框）
进程划分成程序块（页）

- 程序块可装到存储器中可用的存储块中
- 无需用连续页框来存放一个进程
- 操作系统为每个进程生成一个页表
- 通过页表(page table)实现逻辑地址向物理地址转换（Address Mapping ）

逻辑地址（Logical Address）：
- 程序中指令所用地址(进程所在地址空间)，也称为虚拟地址（Virtual Address，简称VA）
物理地址（Physical Address，简称PA）：
- 存放指令或数据的实际内存地址，也称为实地址、主存地址。


根据程序访问局部性可知：可把当前活跃的页面调入主存，其余留在磁盘上！
采用 “按需调页 Demand Paging”方式分配主存！
这就是虚拟存储管理概念

![image.png|400](http://verification.fengzhongzhihan.top/202311271744780.png)
- 30代表了块内偏移量,1代表了逻辑页号,14代表了物理页号

### 6.5.2 虚拟存储系统

**一对矛盾**
- 一方面，主存容量受到限制
- 另一方面，系统程序和应用程序要求主存容量越来越大

**虚拟存储技术的实质**
- 程序员在比实际主存空间大得多的逻辑地址空间中编写程序
- 程序执行时，把当前需要的程序段和相应的数据块调入主存，其他暂不用的部分存放在磁盘上
- 指令执行时，通过硬件将逻辑地址转化为物理地址
- 在发生程序或数据访问失效(缺页)时，由操作系统进行主存和磁盘之间的信息交换

虚拟存储器机制由硬件与操作系统共同协作实现
![image.png|400](http://verification.fengzhongzhihan.top/202311271757098.png)
- 虚拟地址到磁盘物理空间的映射
	- 加载的时候建立, 但此时不会真正调用
- 虚拟地址到内存物理空间的映射
	- 运行的时候建立

### 6.5.3 存储器管理
(类似cache和memory映射)

映射单位: 4kb
cache和memory: 64mb

注意:磁盘地址和虚拟空间之间的映射不是在页表中进行的

虚拟存储器实现方式
- 分页式
- 分段式
- 段页式(max)

主存到外存之间的存取时间是很长的相对而言,因此要减少IO
- 与“Cache--主存”层次相比：页大小（2KB~64KB）比Cache中的Block大得多！根据相对大小而言,

**采用全相联映射！Why?**
- 因为缺页的开销比Cache缺失开销大的多！缺页时需要访问磁盘（约几百万个时钟周期），而cache缺失时，访问主存仅需几十到几百个时钟周期！因此，页命中率比cache命中率更重要！“大页面”和“全相联”可提高页命中率。
**通过软件来处理“缺页”！Why?**
- 缺页时需要访问磁盘（约几百万个时钟周期），慢！不能用硬件实现。
**采用Write Back写策略！ Why?**
- 避免频繁的慢速磁盘访问操作。(不使用write through)
**地址转换用硬件实现！Why?**
- 加快指令执行

### 6.5.4 页表结构
![image.png](http://verification.fengzhongzhihan.top/202312041714793.png)
对于每一个进程而言,都有对应的页表!

一个页表的项数由什么决定？
- 理论上由虚拟地址空间大小决定
每个进程的页表大小一样吗？
- 理论上一样

![image.png](http://verification.fengzhongzhihan.top/202401060002052.png)


**逻辑地址转化为物理地址**

![image.png](http://verification.fengzhongzhihan.top/202312041724196.png)



- 输入逻辑地址,通过页表索引和页表基址寄存器找到位于主存中的页表
- 判断如果v=0,则产生缺页错误,从磁盘读到内存中
	- 此时还可能出现保护违例或访问限制(权限)
- 最后输出物理页号+偏移量(物理地址)

1）缺页（ page fault） 
     产生条件：当Valid（有效位 / 装入位）为 0 时
     相应处理：从磁盘读到内存，若内存没有空间，则还要从内存选择一页替换到磁盘上，替换算法类似于Cache，采用回写法，淘汰时，根据“dirty”位确定是否要写磁盘
     当前指令执行被阻塞，当前进程被挂起，处理结束回到原指令继续执行
2）保护违例（ protection_violation_fault ）或访问违例
      产生条件： 当Access Rights (存取权限)与所指定的具体操作不相符时
      相应处理：在屏幕上显示“内存保护错”或“访问违例”信息
      当前指令的执行被阻塞，当前进程被终止
           Access Rights (存取权限)可能的取值有哪些？
           R = Read-only,  R/W = read/write,  X = execute only


对于页表本身而言,也可以加入缓存TLB
- 将一些常访问的页表项放入TLB,可以加快地址存取速度
![image.png](http://verification.fengzhongzhihan.top/202401060009351.png)


![image.png](http://verification.fengzhongzhihan.top/202312041736949.png)


分段式
- 空间浪费
- 碎片化问题


## 6.6 段页式
分段系统将主存空间按实际程序中的段来划分，每个段在主存中的位置记录在段表中，并附以“段长”项
段表由段表项组成，段表本身也是主存中的一个可再定位段

段页式系统基本思想
**段、页式结合**
- 程序的虚拟地址空间按模块分段、段内再分页，进入主存仍以页为基本单位
- 逻辑地址由段地址、页地址和偏移量三个字段构成
- 好处:内存分配自由+时间短(由O(mn)->O(m+n))

支持至少两种运行模式：
	管理模式(Supervisor Mode)
	     执行系统程序（内核）时处理器所处的模式称为管理模式(Supervisor Mode)，或称管理程序状态，简称管态、管理态、核心态、内核态
	用户模式(User Mode)
	    CPU执行非操作系统的用户程序时，处理器所处的模式就是用户模式，或称用户状态、目标程序状态，简称为目态或用户态
	    
使一部分CPU状态只能由内核程序读写而不能由用户程序读写：这部分状态包括：User/Supervisor模式位、页表首地址、TLB等。OS内核可以用特殊的指令（一般称为管态指令或特权指令）来读写这些状态

提供让CPU在管理模式（内核态）和用户模式（用户态）相互转换的机制：“异常”和“陷阱”（系统调用）使CPU从用户态转到内核态；异常处理中的“返回”指令使CPU从内核态态转到用户态

通过上述三个功能并把页表保存在OS的地址空间，OS就可以更新页表，并防止用户程序改变页表，确保用户程序只能访问由OS分配给的存储空间⚠️upload failed, check dev console

# 7 IO操作实现

## 7.1 用户IO
hello程序的运行过程

![image.png](http://verification.fengzhongzhihan.top/202401061617530.png)


>hello程序何时被装载? 谁来装入? 被谁启动?每次被装到相同的地方? 能否直接访问硬件资源?

- 发生缺页错误的时候; 操作系统 ; CPU; 现代操作系统通常会使用一种称为地址空间布局随机化（ASLR）的技术，这使得同一程序在每次运行时加载到不同的内存地址，以增强安全性; 不能,而程序需要通过操作系统提供的接口（系统调用）来间接访问硬件资源

**操作系统: 应用程序和硬件之间的一个中间软件层**

主要作用
- 硬件资源管理: 防止硬件资源的滥用
	- 统筹安排和调度硬件资源，以防止硬件资源被用户程序滥用
		对于广泛使用的复杂低级设备，为用户程序提供一个简单一致的使用接口
- 为用户提供操作接口, 对于广泛使用复杂低级设备, 为用户提供简单一致的使用接口
- 应用程序如果控制键盘, 则只能向操作系统发出请求! 统一统筹安排

### 7.1.1 传递IO请求方式
 最终用户：键盘、鼠标通过操作界面传递给OS
   用户程序：通过函数（高级语言）转换为系统调用传递给OS

提出I/O请求
- 使用高级语言的标准IO函数
	- 根本上还是调用API
	- 缺点 : a) 标准I/O库函数不能保证文件的安全性（无加/解锁机制）
	   (b) 所有I/O都是同步的，程序必须等待I/O操作完成后才能继续执行
	   (c) 有时不适合甚至无法使用标准I/O库函数实现I/O功能，如，不提供读取文件元数据的函数（元数据包括文件大小和文件创建时间等）
	    (d) 用它进行网络编程会造成易于出现缓冲区溢出等风险
- 使用OS提供的API或系统调用
- 在I/O请求指令序列中，具体I/O请求被转换为一条陷阱指令，在陷阱指令前面则是相应的系统调用参数的设置指令。 
- 每个指令系统中一定有一类陷阱指令（有些机器也称为软中断指令或系统调用指令），主要功能是为操作系统提供灵活的系统调用机制。

### 7.1.2 IO软件的层次
![image.png|240](http://verification.fengzhongzhihan.top/202401061032726.png)
![image.png|450](http://verification.fengzhongzhihan.top/202401061621021.png)

从用户I/O软件切换到内核I/O软件的唯一办法是“异常”机制：系统调用（自陷）

I/O系统的三大特性
![image.png|500](http://verification.fengzhongzhihan.top/202401061035744.png)


系统调用和API区别
- API是总称, 系统调用是特殊情况
- API 函数最终通过调用系统调用实现 I/O。一个API 可能调用多个系统调用，不同 API 可能会调用同一个系统调用。但是，并不是所有 API 都需要调用系统调用。
- 从编程者来看，API 和 系统调用之间没有什么差别。从内核设计者来看，API 和 系统调用差别很大。API 在用户态执行，系统调用封装函数也在用户态执行，但具体服务例程在内核态执行
- 在system_call中如何知道要转到sys_write执行呢？
	- 根据系统调用号

![image.png](http://verification.fengzhongzhihan.top/202401061627039.png)

## 7.2 I/O硬件和软件接口

### 7.2.1 设备控制器的结构

![image.png](http://verification.fengzhongzhihan.top/202401061629024.png)

将I/O控制器中CPU能够访问的各类寄存器称为I/O端口
对外设的访问通过向I/O端口发命令、读状态、读/写数据来进行

**IO端口的寻址方式**
（1）统一编址方式（内存映射方式）
与主存空间统一编址，主存单元和I/O端口在同一个地址空间中。
  (2)独立编址方式（特殊I/O指令方式）
 单独编号，不和主存单元一起编，使成为一个独立的I/O地址空间

### 7.2.2 驱动程序
控制外设进行输入/输出的底层I/O软件是驱动程序
- 驱动程序通过访问I/O端口控制外设进行I/O：
- 将控制命令送到控制寄存器来启动外设工作；
- 读取状态寄存器了解外设和设备控制器的状态；
- 访问数据缓冲寄存器进行数据的输入和输出。

>IA-32中的I/O指令：in、ins、out和outs
in和ins用于将I/O端口的内容取到CPU内的通用寄存器中；
out和outs用于将通用寄存器内容输出到I/O端口。
IN AL, DX：DX中存放I/O端口地址，将I/O端口中的内容取到AL中

in : 从端口中读
out : 放入端口中

## 7.3 驱动程序的三种基本IO方式

### 7.3.1 程序直接控制方式
- 程序直接控制方式(无条件传送/条件传送)(完全为IO服务)
	  - CPU和外设串行工作,速度慢
	  - 实现比较简单
	  - 查询开销极大
![image.png](http://verification.fengzhongzhihan.top/202401061638364.png)

### 7.3.2 中断处理方式
- I/O interrupt  : 中断, 数据准备好再通知CPU
	  - CPU和外设并行工作
	  - 中断检测
	  - 中断响应(发现请求->终止现状->调出服务程序)
		  - - 必须要等到一条指令执行完,才进行中断响应
	  - 中断处理(软件)
	  - 如果有更高优先级来了,那我需要多重中断~ 注意保护现场

![image.png](http://verification.fengzhongzhihan.top/202401061639616.png)

>问题：中断响应的时点与异常处理的时点是否相同？为什么？
通常在指令执行结束时查询有无中断请求，有则立即响应；
而异常发生在指令执行过程中，一旦发现则马上处理。

多重中断处理过程
- 定义 :在一个中断处理（即执行中断服务程序）过程中，若又有新的中断请求发生，而新中断优先级高于正在执行的中断，则应立即中止正在执行的中断服务程序，转去处理新的中断。这种情况为多重中断，也称中断嵌套。

![image.png](http://verification.fengzhongzhihan.top/202401061643874.png)

中断服务程序图示
![image.png](http://verification.fengzhongzhihan.top/202401061657466.png)


多重中断示例
![image.png](http://verification.fengzhongzhihan.top/202401061644076.png)

### 7.3.3 DMA处理方式
- DMA : 磁盘等高速外设
	  - 高速外设和主存之间直接传送数据
	  - 由专门硬件控制总线进行传输(DMA控制器)
	  - 使用总线优先级> CPU
	  - 数据传送过程无需CPU参与
	  - 在DMA控制器控制总线进行数据传送时，CPU执行其他程序, DMA传送结束时，要通过“DMA结束中断”告知CPU

![image.png](http://verification.fengzhongzhihan.top/202401061647903.png)
![image.png](http://verification.fengzhongzhihan.top/202401061647445.png)
![image.png](http://verification.fengzhongzhihan.top/202401061647444.png)



## 7.4 内核空间I/O软件

所有用户程序提出的I/O请求，最终都通过系统调用实现
-> 通过系统调用封装函数中的陷阱指令转入内核I/O软件执行

内核空间I/O软件实现相应系统调用的服务功能
内核空间的I/O软件分三个层次
- 设备无关软件层
	- 操作系统为所有外设的设备驱动程序规定一个统一接口，这样，新设备的驱动程序只要按统一接口规范来编制，就可在不修改操作系统的情况下，添加新设备驱动程序并使用新的外设进行I/O。
	- 所有设备都抽象成文件，设备名和文件名在形式上没有差别   大，所有逻辑数据块的大小相同，这样，高层I/O软件就只需处理简化的抽象设备，从而在高层软件中简化了数据定位等处理 。
- 设备驱动程序层
	- 每个外设或每类外设都有一个设备控制器，其中包含各种I/O端口。 CPU通过执行设备驱动程序中的I/O指令访问个各种I/O端口
- 中断服务程序层

图示
![image.png|475](http://verification.fengzhongzhihan.top/202401061652512.png)

![image.png](http://verification.fengzhongzhihan.top/202401061653979.png)
